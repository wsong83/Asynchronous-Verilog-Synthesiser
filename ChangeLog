##### Mon 18/06/2012
* The major construction of range operations have been finished.
* op_deduct() in netlist::Range is rewritten along with op_normalise_tree().
* Seems like I have finally settle down how to implement range operations. Good!

##### Sun 17/06/2012
* Finally find out that it is kind impossible (or too difficult) to do range operations with variables when the maximal 
  range is unknown. However, when the maximal range is provided, all range expression can be reduced to const range which
  significantly reduce all calculations. The bad news is, all operations are going to be re-write for the third time in 
  these couple of weeks! 
* Add op_and in netlist::RangeArrayCommon for multi-dimension & operation.
* Add op_and_tree in netlist::Range for multi-dimension range & operation.

##### Sat 16/06/2012
* Rewrite >=, <= and == of netlist::Range.

##### Fri 15/06/2012
* Rewrite the & and | operations for netlist::Range to const functions as it will be too complicated to handle range 
  expressions with real VIdentifiers.
* Set up a new class netlist::RangeArrayCommon as the common base class of RangeArray and Range to handled the range array
  related operations, otherwise the same member function are to be defined twice.

##### Thu 14/06/2012
* Add a new class namely netlist::RangeArray to handled multi-dimension range operations. In process.
* Add &, |, >=, and - operation to netlist::Range classes.
* Add >, >=, <, <= to netlist::Number classes.

##### Wed 13/06/2012
* Add elaborate() to netlist::CaseState and netlist::CaseItem. Error types and result types are added accordingly.

##### Tue 12/06/2012
* Add removal and reduction in netlist::Block.
* Add another return value in elaborate(), elab_result_t result, to identifier the required operation in the upper level, 
  such as removal or further reduction.
* Fix the bug in reduce concatenations such as {32{1'b0}}.

##### Mon 11/06/2012
* Add elaborate() in netlist::SeqBlock, netlist::IfState, netlist::Block, netlist::Assign.
* Add ==, != and leading zero triming support for netlist::Number.
* Add a get_type_name() member function in Netlist::NetComp to show component type in string.

##### Sun 10/06/2012
* Fix the on-load error. The problem is fake and it should not stop the elaboration from proceeding further.

##### Sat 09/06/2012
* Add a function named multi_driver_checker() in netlist::Variable to handle the multi-driver check. However, this is far from 
  perfect. Different range selections in different always blocks will cause false alarms. This must be fixed, which means the 
  check should be run after generation blocks are unfolded.
* Add a set_always_pointer() member function to all NetComp classes. It is used to set the pointer to its father 
  netlist::SeqBlock, which will be used for multi-driver check.
* Able to add new modules to the elaboration list automatically.

##### Fri 08/06/2012
* Rewrite update_name() in Module to calculate_name(). Now it is a const function without any side effect in the module.

##### Thu 07/06/2012
* Fix the no-load problem.
* Fix the multiple driver problem, which is caused by uninitilised port directions in instances.
* Add update_ports() in Netlist::Instance to update the ports directions before db_register() in Netlist::Module::elaborate().
* Add find_port() in Netlist::Module.

##### Wed 06/06/2012
* Start to elaborate wires and registers. Have no-driver and multiple-driver bugs so far.
* Store the elaborated modules to the target work library and update the current_design if elaborate successfully.
* Fix the bug in reducing range expressions.
* Fix a bug in the deep_copy() of netlist::Port. As VIdentifier has range definitions inside, it needs to be deep_copied.
* Add a avs_shell command "report_netlist" to show the internals of a module or internal item.
* Show constant numbers in a range expression in the form of plain decimal number instead of fix-width number.
